#include "AFCS_OVERSPEED_PROTECTION.h"

AFCS_OVERSPEED_PROTECTION::AFCS_OVERSPEED_PROTECTION(IAFCS_CONTROLLER* AFCS_CTL) : IAFCS_MODULE(AFCS_CTL)
{
	SURFACE_CONTROLLER = new PID_CONTROLLER(PITCH_ELEVATOR_RECOVERY_FACTOR, 0, 0);
}

inline void AFCS_OVERSPEED_PROTECTION::SetIdleThrust()
{
	/// Send command for 21% Throttle Lever Angle (TLA) to the simulator
	AFCS_CTL->GENERAL_ENG_THROTTLE_LEVER_POSITION.GENERAL_ENG_THROTTLE_LEVER_POSITION_1 = 21.0f;
	AFCS_CTL->GENERAL_ENG_THROTTLE_LEVER_POSITION.GENERAL_ENG_THROTTLE_LEVER_POSITION_2 = 21.0f;
	AFCS_CTL->GENERAL_ENG_THROTTLE_LEVER_POSITION.GENERAL_ENG_THROTTLE_LEVER_POSITION_3 = 21.0f;
	AFCS_CTL->GENERAL_ENG_THROTTLE_LEVER_POSITION.GENERAL_ENG_THROTTLE_LEVER_POSITION_4 = 21.0f;

	SimConnect_SetDataOnSimObject(AFCS_CTL->hSimConnect, AFCS_CTL->DEFINITION_GENERAL_ENG_THROTTLE_LEVER_POSITION, SIMCONNECT_OBJECT_ID_USER, 0, 0, sizeof(AFCS_CTL->GENERAL_ENG_THROTTLE_LEVER_POSITION), &AFCS_CTL->GENERAL_ENG_THROTTLE_LEVER_POSITION);
}

void AFCS_OVERSPEED_PROTECTION::RunModuleLogic()
{
	double PITCH_DESIRED_RATE = 0;

	/// If the overspeed warning is active, use maximum elevator available pull up
	if (AFCS_CTL->FLIGHT_PARAMETERS.OVERSPEED_WARNING == true)
	{
		PITCH_DESIRED_RATE = PITCH_RECOVERY_RATE;

		/// If the autothrust connection to the simulator is not inhibited, set power to flight idle
		if (AFCS_CTL->AFCS_ENGAGEMENT_STATUS.AUTOTHROTTLE_INHIBIT != true) SetIdleThrust();
	}

	auto PITCH_CONTROLLER_OUTPUT = SURFACE_CONTROLLER->Update(PITCH_DESIRED_RATE - AFCS_CTL->FLIGHT_PARAMETERS.ROTATION_VELOCITY_BODY_Y);

	if (PITCH_CONTROLLER_OUTPUT > 1) PITCH_CONTROLLER_OUTPUT = 1;
	if (PITCH_CONTROLLER_OUTPUT < -1) PITCH_CONTROLLER_OUTPUT = -1;

	/// Send updated elevator position to the simulator
	AFCS_CTL->ELEVATOR_POSITION.ELEVATOR_POSITION = PITCH_CONTROLLER_OUTPUT;
	SimConnect_SetDataOnSimObject(AFCS_CTL->hSimConnect, AFCS_CTL->DEFINITION_ELEVATOR_POSITION, SIMCONNECT_OBJECT_ID_USER, 0, 1, sizeof(AFCS_CTL->ELEVATOR_POSITION), &AFCS_CTL->ELEVATOR_POSITION);
}
